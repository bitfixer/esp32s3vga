#include "VGA.h"
#include <esp_log.h>
#include <esp_lcd_panel_ops.h>
#include <string.h>

#define VGA_PIN_NUM_HSYNC          4
#define VGA_PIN_NUM_VSYNC          3
#define VGA_PIN_NUM_DE             -1

// note: PCLK pin is not needed for VGA output.
// however, the current version of the esp lcd rgb driver requires this to be set
// to keep this pin unused and available for something else, you need a patched version
// of the driver (for now)
#if PATCHED_LCD_DRIVER
#define VGA_PIN_NUM_PCLK           -1
#else
#define VGA_PIN_NUM_PCLK           5
#endif
#define VGA_PIN_NUM_DATA0          6
#define VGA_PIN_NUM_DATA1          7
#define VGA_PIN_NUM_DATA2          8
#define VGA_PIN_NUM_DATA3          9
#define VGA_PIN_NUM_DATA4          34
#define VGA_PIN_NUM_DATA5          36
#define VGA_PIN_NUM_DATA6          37
#define VGA_PIN_NUM_DATA7          35
#define VGA_PIN_NUM_DISP_EN        -1

static const char *TAG = "vga";

bool VGA::initWithSize(int frameWidth, int frameHeight, int bits) {
    int hborder = 9999;
    int vborder = 9999;

    int rw[6];
    int rh[6];
    int best = -1;

    rw[0] = 320;
    rh[0] = 200;

    rw[1] = 320;
    rh[1] = 240;

    rw[2] = 400;
    rh[2] = 300;

    rw[3] = 640;
    rh[3] = 400;

    rw[4] = 640;
    rh[4] = 480;

    rw[5] = 800;
    rh[5] = 600;

    for (int rr = 0; rr < 6; rr++) {
        if (frameWidth > rw[rr] || frameHeight > rh[rr]) {
            continue;
        }

        int hb = (rw[rr] - frameWidth) / 2;
        int vb = (rh[rr] - frameHeight) / 2;

        if ((hb + vb) <= (hborder + vborder)) {
            hborder = hb;
            vborder = vb;
            best = rr;
        }
    }

    if (best == -1) {
        ESP_LOGI(TAG, "could not initialize with %d %d", frameWidth, frameHeight);
        return false;
    }

    int scale = 1;
    if (best < 3) {
        scale = 2;
    }
    int screenWidth = rw[best] * scale;
    int screenHeight = rh[best] * scale;

    ESP_LOGI(TAG, "frame %d %d: screen %d %d %d %d %d", frameWidth, frameHeight, screenWidth, screenHeight, scale, hborder, vborder);
    return init(screenWidth, screenHeight, scale, hborder, vborder, bits, NULL, true);
}

bool VGA::validConfig(int width, int height, int scale, int hborder, int vborder, int bits, int* pins, bool usePsram) {

    if (scale < 1 || scale > 2) {
        return false;
    }

    if (width == 800 && height == 600) {
        return true;
    } else if (width == 640 && height == 480) {
        return true;
    } else if (width == 640 && height == 400) {
        return true;
    } else if (width == 640 && height == 350) {
        return true;
    }

    return false;
}

bool VGA::init(int width, int height, int scale, int hborder, int vborder, int bits, int* pins, bool usePsram) {

    if (!validConfig(width, height, scale, hborder, vborder, bits, pins, usePsram)) {
        ESP_LOGE(TAG, "error: invalid configuration");
        return false;
    }

	// temp replace
	_frameScale = scale;
	_frameWidth = width / _frameScale;
	_frameHeight = height / _frameScale;

    _hBorder = hborder;
    _frameWidth -= (2*_hBorder);

    _vBorder = vborder;
    _frameHeight -= (2*_vBorder);

	_screenWidth = width;
	_screenHeight = height;
    _colorBits = bits;
    _bounceBufferLines = height / 10;

    int pixelClockHz = 0;
    if (width == 800 && height == 600) {
        pixelClockHz = 40000000;
    } else if (width == 640 && height == 480) {
        pixelClockHz = 36000000;
    } else if (width == 640 && height == 400) {
        // note: nominal pixel frequency here is 25.175 MHz
        // 25.0 MHz experimentally shown to generate a less noisy picture,
        // since this is more cleanly generated by the internal oscillator
        pixelClockHz = 25000000;
    } else if (width == 640 && height == 350) {
        pixelClockHz = 25000000;
    }

	ESP_LOGI(TAG, "Create semaphores");
    _sem_vsync_end = xSemaphoreCreateBinary();
    assert(_sem_vsync_end);
    _sem_gui_ready = xSemaphoreCreateBinary();
    assert(_sem_gui_ready);

	ESP_LOGI(TAG, "Install RGB LCD panel driver");
    esp_lcd_rgb_panel_config_t panel_config;
    memset(&panel_config, 0, sizeof(esp_lcd_rgb_panel_config_t));

    panel_config.data_width = 8;
    panel_config.psram_trans_align = 64,
    panel_config.num_fbs = 0;
    panel_config.clk_src = LCD_CLK_SRC_PLL240M;
    panel_config.bounce_buffer_size_px = _bounceBufferLines * _screenWidth;
    panel_config.disp_gpio_num = -1;
    panel_config.pclk_gpio_num = VGA_PIN_NUM_PCLK;
    panel_config.vsync_gpio_num = VGA_PIN_NUM_VSYNC;
    panel_config.hsync_gpio_num = VGA_PIN_NUM_HSYNC;
    panel_config.de_gpio_num = VGA_PIN_NUM_DE;

    // set defaults for pins
    panel_config.data_gpio_nums[0] = VGA_PIN_NUM_DATA0;
    panel_config.data_gpio_nums[1] = VGA_PIN_NUM_DATA1;
    panel_config.data_gpio_nums[2] = VGA_PIN_NUM_DATA2;
    panel_config.data_gpio_nums[3] = VGA_PIN_NUM_DATA3;
    panel_config.data_gpio_nums[4] = VGA_PIN_NUM_DATA4;
    panel_config.data_gpio_nums[5] = VGA_PIN_NUM_DATA5;
    panel_config.data_gpio_nums[6] = VGA_PIN_NUM_DATA6;
    panel_config.data_gpio_nums[7] = VGA_PIN_NUM_DATA7;

    // check for pin definitions
    if (pins) {
        for (int i = 0; i < 8; i++) {
            if (i < bits) {
                panel_config.data_gpio_nums[i] = pins[i];
            }
        }
    }
        
    panel_config.timings.pclk_hz = pixelClockHz;
    panel_config.timings.h_res = _screenWidth;
    panel_config.timings.v_res = _screenHeight;
    
    // timings for different VGA resolutions
    if (width == 800 && height == 600) {
        panel_config.timings.hsync_back_porch = 88;
        panel_config.timings.hsync_front_porch = 40;
        panel_config.timings.hsync_pulse_width = 128;
        panel_config.timings.vsync_back_porch = 23;
        panel_config.timings.vsync_front_porch = 1;
        panel_config.timings.vsync_pulse_width = 4;
    } else if (width == 640 && height == 480) {
        panel_config.timings.hsync_back_porch = 80;
        panel_config.timings.hsync_front_porch = 56;
        panel_config.timings.hsync_pulse_width = 56;
        panel_config.timings.vsync_back_porch = 25;
        panel_config.timings.vsync_front_porch = 1;
        panel_config.timings.vsync_pulse_width = 3;
    } else if (width == 640 && height == 400) {
        panel_config.timings.hsync_back_porch = 48;
        panel_config.timings.hsync_front_porch = 16;
        panel_config.timings.hsync_pulse_width = 96;
        panel_config.timings.vsync_back_porch = 35;
        panel_config.timings.vsync_front_porch = 12;
        panel_config.timings.vsync_pulse_width = 2;
    } else if (width == 640 && height == 350) {
        panel_config.timings.hsync_back_porch = 48;
        panel_config.timings.hsync_front_porch = 16;
        panel_config.timings.hsync_pulse_width = 96;
        panel_config.timings.vsync_back_porch = 60;
        panel_config.timings.vsync_front_porch = 37;
        panel_config.timings.vsync_pulse_width = 2;
    }

    panel_config.timings.flags.pclk_active_neg = true;
    panel_config.timings.flags.hsync_idle_low = 0;
    panel_config.timings.flags.vsync_idle_low = 0;

    panel_config.flags.fb_in_psram = 0;
    panel_config.flags.double_fb = 0;
    panel_config.flags.no_fb = 1;

    ESP_ERROR_CHECK(esp_lcd_new_rgb_panel(&panel_config, &_panel_handle));

    // allocate frame buffers in memory
    int fbSize = _frameWidth*_frameHeight;
    if (_colorBits == 3) {
        fbSize /= 2;
    } else if (_colorBits == 1) {
        fbSize /= 8;
    }

    for (int i = 0; i < 2; i++) {
        if (usePsram) {
             ESP_LOGI(TAG, "allocating in spi ram");
            _frameBuffers[i] = (uint8_t*)heap_caps_malloc(fbSize, MALLOC_CAP_SPIRAM);
        } else {
             ESP_LOGI(TAG, "allocating in main memory");
            _frameBuffers[i] = (uint8_t*)malloc(fbSize);
        }
        assert(_frameBuffers[i]);
    }

    memset(_frameBuffers[0], 255, _frameWidth*_frameHeight);
    _lastBounceBufferPos = _screenWidth*(_screenHeight-_bounceBufferLines);

    ESP_LOGI(TAG, "Register event callbacks");
    esp_lcd_rgb_panel_event_callbacks_t cbs = {
    	.on_vsync = vsyncEvent,
        .on_bounce_empty = bounceEvent,
    };
    ESP_ERROR_CHECK(esp_lcd_rgb_panel_register_event_callbacks(_panel_handle, &cbs, this));

    ESP_LOGI(TAG, "Initialize RGB LCD panel");
    ESP_ERROR_CHECK(esp_lcd_panel_reset(_panel_handle));
    ESP_ERROR_CHECK(esp_lcd_panel_init(_panel_handle));
    ESP_LOGI(TAG, "Init complete");

    return true;
}

bool VGA::deinit() {
    esp_err_t err = esp_lcd_panel_del(_panel_handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "error deleting rgb lcd panel");
        return false;
    }

    _panel_handle = NULL;
    return true;
}

void VGA::vsyncWait() {
	// get draw semaphore
    xSemaphoreGive(_sem_gui_ready);
    xSemaphoreTake(_sem_vsync_end, portMAX_DELAY);
}

uint8_t* VGA::getDrawBuffer() {
	if (_frameBufferIndex == 0) {
		return _frameBuffers[1];
	} else {
		return _frameBuffers[0];
	}
}

bool VGA::vsyncEvent(esp_lcd_panel_handle_t panel, const esp_lcd_rgb_panel_event_data_t *edata, void *user_ctx) {
	return true;
}

void VGA::swapBuffers() {
    if (xSemaphoreTakeFromISR(_sem_gui_ready, NULL) == pdTRUE) {
        if (_frameBufferIndex == 0) {
            _frameBufferIndex = 1;
        } else {
            _frameBufferIndex = 0;
        }
        xSemaphoreGiveFromISR(_sem_vsync_end, NULL);
    }
}

bool VGA::bounceEvent(esp_lcd_panel_handle_t panel, void* bounce_buf, int pos_px, int len_bytes, void* user_ctx) {
	VGA* vga = (VGA*)user_ctx;
    uint8_t* bbuf = (uint8_t*)bounce_buf;
    bool skip = false;

    //int div = vga->_frameScale * vga->_frameScale;
    int pixelsPerByte = 1;
    if (vga->_colorBits == 3) {
        pixelsPerByte = 2;
    } else if (vga->_colorBits == 1) {
        pixelsPerByte = 8;
    }

    int screenLineIndex = pos_px / vga->_screenWidth;
    int bufLineIndex = screenLineIndex / vga->_frameScale;

    bufLineIndex -= vga->_vBorder;
    if (bufLineIndex >= vga->_frameHeight) {
        // past the bottom of the frame
        memset(bounce_buf, 0, len_bytes);
        if (pos_px >= vga->_lastBounceBufferPos) {
            vga->swapBuffers();
        }
        return true;
    }

    if (bufLineIndex < 0) {
        int lineAdj = (-bufLineIndex)*vga->_frameScale;
        int pxAdj = lineAdj*vga->_screenWidth;
        if (pxAdj >= len_bytes) {
            // this buffer should be empty, before the first line of the frame
            // clear
            memset(bounce_buf, 0, len_bytes);
            return true;
        }

        memset(bounce_buf, 0, pxAdj);
        bbuf += pxAdj;
        len_bytes -= pxAdj;
        bufLineIndex = 0;
    }

    uint8_t* pptr = vga->_frameBuffers[vga->_frameBufferIndex] + (bufLineIndex*vga->_frameWidth/pixelsPerByte);
    int screenLines = len_bytes / vga->_screenWidth;
    int lines = screenLines / vga->_frameScale;

    if (lines > (vga->_frameHeight-bufLineIndex)) {
        int ll = vga->_frameHeight-bufLineIndex;
        int clearLines = lines-ll;
        lines = ll;

        int screenClearIndex = lines * vga->_frameScale;
        int screenClearLines = clearLines * vga->_frameScale;
        uint8_t* clearPtr = bbuf + (screenClearIndex*vga->_screenWidth);
        memset(clearPtr, 0, screenClearLines*vga->_screenWidth);
    }

    if (vga->_frameScale == 1 && vga->_colorBits == 8) {
        // just copy the bytes
        if (vga->_hBorder == 0 && vga->_vBorder == 0) {
            uint8_t* bbptr = (uint8_t*)bbuf;
            int copyBytes = lines*vga->_screenWidth;
            memcpy(bbptr, pptr, copyBytes);
        } else {
            uint8_t* bbptr = (uint8_t*)bbuf;
            bbptr += vga->_hBorder;
            for (int i = 0; i < lines; i++) {
                memcpy(bbptr, pptr, vga->_frameWidth);
                bbptr += vga->_screenWidth;
                pptr += vga->_frameWidth;
            }
        }
    } else if (vga->_frameScale == 1 && vga->_colorBits == 3) {
        uint8_t* bbptr = (uint8_t*)bbuf;
        bbptr += vga->_hBorder;
        uint8_t pixelBits;
        for (int y = 0; y < lines; y++) {
            uint8_t* lineptr = bbptr;
            for (int x = 0; x < vga->_frameWidth; x += 10) {
                // partially unrolled loop for speed
                pixelBits = *pptr;
                *(bbptr++) = pixelBits & 0b00000111;
                pixelBits >>= 4;
                *(bbptr++) = pixelBits & 0b00000111;
                pptr++;
                pixelBits = *pptr;
                *(bbptr++) = pixelBits & 0b00000111;
                pixelBits >>= 4;
                *(bbptr++) = pixelBits & 0b00000111;
                pptr++;
                pixelBits = *pptr;
                *(bbptr++) = pixelBits & 0b00000111;
                pixelBits >>= 4;
                *(bbptr++) = pixelBits & 0b00000111;
                pptr++;
                pixelBits = *pptr;
                *(bbptr++) = pixelBits & 0b00000111;
                pixelBits >>= 4;
                *(bbptr++) = pixelBits & 0b00000111;
                pptr++;
                pixelBits = *pptr;
                *(bbptr++) = pixelBits & 0b00000111;
                pixelBits >>= 4;
                *(bbptr++) = pixelBits & 0b00000111;
                pptr++;
            }
            bbptr = lineptr + vga->_screenWidth;
        }
    } else if (vga->_frameScale == 2 && vga->_colorBits == 8) {
        uint8_t* bbptr = bbuf;
        bbptr += vga->_hBorder*vga->_frameScale;
        for (int y = 0; y < lines; y++) {
            uint8_t* lineptr = bbptr;
            for (int x = 0; x < vga->_frameWidth; x += 10) {
                // partially unrolled loop for speed
                *(bbptr++) = *pptr;
                *(bbptr++) = *(pptr++);
                *(bbptr++) = *pptr;
                *(bbptr++) = *(pptr++);
                *(bbptr++) = *pptr;
                *(bbptr++) = *(pptr++);
                *(bbptr++) = *pptr;
                *(bbptr++) = *(pptr++);
                *(bbptr++) = *pptr;
                *(bbptr++) = *(pptr++);
                *(bbptr++) = *pptr;
                *(bbptr++) = *(pptr++);
                *(bbptr++) = *pptr;
                *(bbptr++) = *(pptr++);
                *(bbptr++) = *pptr;
                *(bbptr++) = *(pptr++);
                *(bbptr++) = *pptr;
                *(bbptr++) = *(pptr++);
                *(bbptr++) = *pptr;
                *(bbptr++) = *(pptr++);
            }
            bbptr = lineptr + vga->_screenWidth;
            memcpy(bbptr, lineptr, vga->_frameWidth*vga->_frameScale);
            bbptr += vga->_screenWidth;
        }
    } else if (vga->_frameScale == 2 && vga->_colorBits == 3) {
        uint8_t* bbptr = bbuf;
        bbptr += vga->_hBorder*vga->_frameScale;
        uint8_t pixelBits;
        for (int y = 0; y < lines; y++) {
            uint8_t* lineptr = bbptr;
            for (int x = 0; x < vga->_frameWidth; x += 10) {
                // partially unrolled loop for speed
                pixelBits = *pptr;
                *(bbptr++) = pixelBits & 0b00000111;
                *(bbptr++) = pixelBits & 0b00000111;
                pixelBits >>= 4;
                *(bbptr++) = pixelBits & 0b00000111;
                *(bbptr++) = pixelBits & 0b00000111;
                pptr++;
                pixelBits = *pptr;
                *(bbptr++) = pixelBits & 0b00000111;
                *(bbptr++) = pixelBits & 0b00000111;
                pixelBits >>= 4;
                *(bbptr++) = pixelBits & 0b00000111;
                *(bbptr++) = pixelBits & 0b00000111;
                pptr++;
                pixelBits = *pptr;
                *(bbptr++) = pixelBits & 0b00000111;
                *(bbptr++) = pixelBits & 0b00000111;
                pixelBits >>= 4;
                *(bbptr++) = pixelBits & 0b00000111;
                *(bbptr++) = pixelBits & 0b00000111;
                pptr++;
                pixelBits = *pptr;
                *(bbptr++) = pixelBits & 0b00000111;
                *(bbptr++) = pixelBits & 0b00000111;
                pixelBits >>= 4;
                *(bbptr++) = pixelBits & 0b00000111;
                *(bbptr++) = pixelBits & 0b00000111;
                pptr++;
                pixelBits = *pptr;
                *(bbptr++) = pixelBits & 0b00000111;
                *(bbptr++) = pixelBits & 0b00000111;
                pixelBits >>= 4;
                *(bbptr++) = pixelBits & 0b00000111;
                *(bbptr++) = pixelBits & 0b00000111;
                pptr++;
            }
            bbptr = lineptr + vga->_screenWidth;
            memcpy(bbptr, lineptr, vga->_frameWidth*vga->_frameScale);
            bbptr += vga->_screenWidth;
        }
    } else if (vga->_colorBits == 1) {
        uint8_t* bbptr = bbuf;
        bbptr += vga->_hBorder*vga->_frameScale;
        uint8_t pixelBits;
        for (int y = 0; y < lines; y++) {
            uint8_t* lineptr = bbptr;
            for (int x = 0; x < vga->_frameWidth; x += 8) {
                // partially unrolled loop for speed
                pixelBits = *pptr;
                bbptr += 8;
                *(--bbptr) = pixelBits & 0b00000001;
                pixelBits >>= 1;
                *(--bbptr) = pixelBits & 0b00000001;
                pixelBits >>= 1;
                *(--bbptr) = pixelBits & 0b00000001;
                pixelBits >>= 1;
                *(--bbptr) = pixelBits & 0b00000001;
                pixelBits >>= 1;
                *(--bbptr) = pixelBits & 0b00000001;
                pixelBits >>= 1;
                *(--bbptr) = pixelBits & 0b00000001;
                pixelBits >>= 1;
                *(--bbptr) = pixelBits & 0b00000001;
                pixelBits >>= 1;
                *(--bbptr) = pixelBits & 0b00000001;
                pptr++;
                bbptr += 8;
            }
            
            bbptr = lineptr + vga->_screenWidth;
        }
    }

    if (pos_px >= vga->_lastBounceBufferPos) {
        vga->swapBuffers();
    }

    return true;
}